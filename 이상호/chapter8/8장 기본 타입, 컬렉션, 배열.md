# 8장 기본 타입, 컬렉션, 배열

- 원시 타입과 다른 기본 타입 및 자바 타입과의 관계
- 코틀린 컬렉션과 배열 및 이들의 널 가능성과 상호운용성

## 8.1 원시 타입과 기본 타입

- 코틀린은 원시 타입과 래퍼 타입을 구분하지 않음

## 구분하지 않은 이유?

- 코틀린이 타입을 추상화해서 알아서 처리해 주기 때문
- 추상화한 이유는
  - 개발 간결성	
    - 개발자가 int vs Integer를 고민하지 않아도 됨
  - Null 안정성 지원
    - Kotlin에서는 null 가능성을 타입 시스템으로 제어 (Int?)
  - 일관성
    - 모든 타입을 객체처럼 다룰 수 있으니 컬렉션, 제네릭 등에서도 통일성
  - 성능 유지
    - 내부적으로는 컴파일 시 자동으로 최적화 (원시 타입 사용)

### 8.1.1 정수, 부동소수점 수, 문자, 불리언 값을 원시 타입으로 표현

- 코틀린은 원시 타입과 래퍼 타입을 구분하지 않음
  - 항상 같은 타입을 사용
- 래퍼 타입을 따로 구분하지 않고 숫자 타입 등 원시 타입의 값에 대해 메서드 호출 가능
- 실행 시점에 숫자 타입은 가능한 한 효율적인 방식으로 표현
  - 대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일

### 8.1.2 양수를 표현하기 위해 모든 비트 범위 사용: 부호 없는 수 타입

- 일반적인 원시 타입을 확장해 부호 없는 타입을 제공
- 부호 없는 숫자 타입
  - UByte: 0 ~ 255
  - UShort: 0 ~ 65535
  - Uint: 0 ~ 2^32 - 1
  - ULong: 0 ~ 2^64 - 1
- 부호 없는 숫자 타입들은 상응하는 부호 있는 타입의 범위를 `시프트` 해서 같은 크기의 메모리를 사용해 더 큰 양수 범위를 표현

### 8.1.3 널이 될 수 있는 기본 타입: Int?, Boolean? 등

- 코틀린의 null 이 될 수 있는 기본 타입은 자바의 래퍼 타입으로 컴파일
- 제네릭 클래스의 경우 래퍼 타입을 사용
- 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 함

### 8.1.4 수 변환

- 코틀린과 자바의 가장 큰 차이점 중 하나는 숫자를 변환하는 방식
- 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우에도 자동 변환은 불가능
- 대신 직접 변환 메서드를 호출
- 코틀린은 모든 원시 타입(Boolean 제외)에 대한 변환 함수를 제공
- 이 중에는 더 표현 범위가 넓은 타입으로 변환하는 함수도 있고, 더 표현 범위가 좁은 타입으로 변환하면서 값을 벗어나는 경우에는 일부를 잘라내는 함수도 있다.
- 숫자 리터럴 사용 시 직절 변환하지 않더라도 타입이 알려진 변수에 대입하거나 함수에게 인자로 넘기면 컴파일러가 필요한 변환을 자동으로 넣어줌
- 코틀린 산술 연산자에서도 자바와 똑같이 숫자 연산 시 오버플로나 언더플로가 발생 가능

### 8.1.5 Any와 Any?: 코틀린 타입 계층의 뿌리

- 자바에서 Object 가 클래스 계층의 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입
- 자바에서는 참조 타입만 Object 에 포함되며, 원시 타입은 그런 계층에 들어있지 않음
  - 즉, Object 타입의 객체가 필요한 경우 in t와 같은 원시 타입을 래퍼 타입으로 감싸야 함
- 코틀린에서는 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상
  - 만약 널을 포함하는 모든 값을 대입할 변수를 선언하려면 쉽게 유추할 수 있듯이 Any? 타입을 사용

### 8.1.6 Unit 타입: 코틀린의 void

- 코틀린의 Unit 타입은 자바의 void 와 같은 기능

```kotlin
fun f(): Unit { /* ... */ }

fun f() { /* ... */ }
```

- 위 코드의 첫번째 줄과 두번째 줄은 같은 의미
- 즉, 반환 타입이 Unit 인 함수는 반환 타입 선언이 없는 함수와 같음

코틀린의 Unit 이 자바 void 와 다른 점
- Unit 은 모든 기능을 갖는 일반적인 타입이며, void 와 달리 Unit 을 타입 인자로 사용 가능
- 즉, 묵시적으로 Unit 을 반환하는 함수인 것이다.

이 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit 을 쓸 때 유용

```kotlin
interface Processor<T> { 
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    override fun process() { // Unit 을 반환하지만 타입을 지정할 필요는 없다.
        // 업무 처리 코드
    } //여기서 따로 return을 명시할 필요가 없다.
}
```

- 타입 인자로 '값 없음'을 표현한다고 생각하면 된다.

### 8.1.7 Nothing 타입: 이 함수는 결코 반환되지 않는다

- 코틀린에는 성공적으로 값을 돌려주는 일이 없으므로 '반환 값'이라는 개념 자체가 의미 없는 함수가 일부 존재
  - 예를 들어 테스트 라이브러리들은 fail 이라는 함수를 제공하는 경우가 많은데, fail 은 특별한 메세지가 들어있는 예외를 던져서 현재 테스트를 실패
  - 다른 예로는 무한 루프를 도는 함수도 값을 반환하며, 정상적으로 끝나지 않음
- 그런 경우를 표현하기 위해 코틀린에는 `Nothing` 이라는 특별한 반환 타입이 있다.
  - `Nothing` 타입은 아무 값도 포함하지 않음
  - `Nothing` 은 함수의 반환 타입이나 반환 타입으로 쓰일 파라미터로만 사용 가능
  - 그 외의 다른 용도로 사용하는 경우 `Nothing` 타입의 변수를 선언하더라도 그 변수에 아무 값도 저장할 수 없으므로 아무 의미가 없음

## 8.2 컬렉션과 배열

- 코틀린의 컬렉션 지원
- 자바와 코틀린 컬렉션 간의 관계

### 8.2.1 널에 될 수 있는 값의 컬렉션과 널이 될 수 있는 컬렉션

- 컬렉션 안에 널 값을 넣을 수 있는지의 여부는 어떤 변수의 값이 널이 될 수 있는지의 여부와 마찬가지로 매우 중요
- 변수 타입 뒤에 `?` 를 붙이면 그 변수에 널을 저장할 수 있다는 뜻인 것처럼 타입 인자로 쓰인 타입에도 같은 표시를 사용
- 널이 될 수 있도록 컬렉션을 만들 때에는 널이 될 수 있는 게 컬렉션의 원소인지 컬렉션 자체인지를 헷갈리면 안된다.
- 경우에 따라 널이 될 수 있는 값으로 이루어진 널이 될 수 있는 리스트를 정의
  - 이 경우 쉽게 유추할 수 있듯이 `List<Int?>?` 와 같이 표현
- 이런 리스트를 처리할 때는 변수에 대해 널 검사를 수행한 다음에 그 리스트에 속한 모든 원소에 대해 다시 널 검사를 수행

### 8.2.2 읽기 전용과 변경 가능한 컬렉션

- 코틀린 컬렉션과 자바 컬렉션을 나누는 가장 중요한 특성 하나는 코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리
- Collection 인터페이스를 사용하는 경우
  - 컬렉션 안의 원소에 이터레이션
  - 컬렉션의 크기를 얻음
  - 어떤 값이 컬렉션 안에 들어있는지 검사
  - 컬렉션에서 데이터를 읽는 여러 다른 연산을 수행
  - 원소를 추가하거나 제거하는 메서드는 없음
- MutableCollection 인터페이스를 사용하는 경우
  - 원소를 추가함
  - 원소를 삭제함
  - 컬렉션 안의 원소를 모두 지움
  - Collection 을 확장하면서 컬렉션 내용을 변경하는 메서드를 더 제공함
- 읽기 전용 컬렉션이 항상 스레드 안전하지는 않다는 점을 명심
  - 다중 스레드 환경에서 데이터를 다루는 경우 그 데이터를 적절히 동기화하거나 동시 접근을 허용하는 데이터 구조를 활용

### 8.2.3 코틀린 컬렉션과 자바 컬렉션은 밀접히 연관됨

- 모든 코틀린 컬렉션은 그에 상응하는 자바 컬렉션 인터페이스의 인스턴스이므로 코틀린과 자바를 오갈 때 아무 변환도 필요 없음
- 하지만 코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현을 제공
- 자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않음
- 코틀린에서 읽기 전용 컬렉션으로 선언된 객체라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있음
- 따라서 컬렉션을 자바로 넘기는 코틀린 프로그램을 작성한다면 호출하려는 자바 코드가 컬렉션을 변경할지 여부에 따라 올바른 파라미터 타입을 사용

### 8.2.4 자바에서 선언한 컬렉션은 코틀린에서 플랫폼 타입으로 보임

- 플랫폼 타입의 경우 코틀린 쪽에서는 널 관련 정보가 없음
  - 컴파일러는 코틀린 코드가 그 타입을 널이 될 수 있는 타입이나 널이 될 수 없는 타입 어느 쪽으로든 사용할 수 있게 허용
  - 자바쪽에서 선언한 컬렉션 타입의 변수를 코틀린에서는 플랫폼 타입으로 본다.
- 플랫폼 타입인 컬렉션은 기본적으로 변경 가능성에 대해 알 수 없음
  - 코틀린 코드는 그 타입을 읽기 전용 컬렉션이나 변경 가능한 컬렉션 어느 쪽으로든 다룰 수 있음
- 컬렉션 타입이 시그니처에 들어간 자바 메서드 구현을 오버라이드하려는 경우 읽기 전용 컬렉션과 변경 가능 컬렉션의 차이가 문제 가능성
- 플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메서드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정
- 이런 상황에는 아래의 여러가지 요소들을 선택하여 코틀린에서 사용할 컬렉션 타입에 반영
  - 컬렉션이 널이 될 수 있는가?
  - 컬렉션의 원소가 널이 될 수 있는가?
  - 오버라이드하는 메서드가 컬렉션을 변경할 수 있는가?

### 8.2.5 성능과 상호운용을 위해 객체의 배열이나 원시 타입의 배열을 만들기

- 코틀린에서 배열을 만드는 방법은 다양하다.
  - arrayOf 함수에 원소를 넘기면 배열을 생성 
  - arrayOfNulls 함수에 정수 값을 인자로 넘기면 모든 원소가 null 이고 인자로 넘긴 값과 크기가 같은 배열 생성
  - Array 생성자는 배열 크기와 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화
    - arrayOf를 쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경우 이 생성자를 사용
- 다른 제네릭 타입에서처럼 배열 타입의 타입 인자도 항상 객체 타입이 된다.
- 코틀린은 원시 타입의 배열을 표현하는 별도 클래스(IntArray , ByteArray , CharArray , BooleanArray등)를 각 원시 타입마다 하나씩 제공
- 원시 타입의 배열을 만드는 방법은 다음과 같다.
  - 각 배열 타입의 생성자는 size 인자를 받아서 해당 원시 타입의 디폴트 값(보통은 0)으로 초기화된 size 크기의 배열을 반환
  - 팩토리(IntArray를 생성하는 intArrayOf 등) 함수는 여러 값을 가변 인자로 받아서 그런 값이 들어간 배열을 반환
  - 크기와 람다를 인자로 받는 생성자를 사용